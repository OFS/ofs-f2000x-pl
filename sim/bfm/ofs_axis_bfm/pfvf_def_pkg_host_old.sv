//
// Generated by OFS script gen_pfvf_def_pkg.py
//    Date/Time.........: 2023-12-05 12:49:47.787483
//    Configuration File: /nfs/site/disks/swuser_work_thofion/builds/mithrandir/ofs_bfm_f2000x/n6001@commit/sim/scripts/qip_gen/quartus_proj_dir/ofs_ip_cfg_db/ofs_ip_cfg_pcie_ss.vh

`ifndef __PFVF_DEF_PKG_HOST__
`define __PFVF_DEF_PKG_HOST__

package pfvf_def_pkg_host;

//----------------------------------
// Parameter Definitions for Package
//----------------------------------

   localparam AXI_ST_ADDR_WIDTH = 64;

   typedef enum {
      PF0,
      PF0_VF0,
      PF0_VF1,
      PF0_VF2,
      PF1,
      PF2,
      PF3,
      PF4
   } pfvf_type_t;

   localparam NUM_OF_PFVF_FUNCTIONS = 8;

   typedef struct packed {
      bit  [2:0] pfn;
      bit [10:0] vfn;
      bit        vfa;
   } pfvf_attr_struct;

   //typedef logic[14:0] pfvf_attr_vector_t;
   typedef logic[63:0] pfvf_addr_t;

//------------------------------------------------------------------------------------------
// BAR Address Assignments:
//    The following address assignments are done for the base addresses that are provided   
//    to the PF/VF MUX.  These values can be randomized if desired.                         
//    Note that these values will determine if the Power User PCIe Header will be in a 4DW  
//    or 3DW format.                                                                        
//    Although each of the addresses are defined for 64-bits, these are the base addresses. 
//    Address offsets may be added or logically OR'ed with the lower bits to create an      
//    effective address for the PF/VF range desired.  For example, PF0 is currently using   
//    the lower 20 bits of address, leaving the upper address bits [63:20] (44 bits) for    
//    the BAR decode: 64'bXXXX_XXXX_XXX0_0000.  If we assign 'h0000_0000_8000_0000 for PFO  
//    and want to access a register at offset 'h0_4000, then the resulting address would be:
//    64'h0000_0000_8000_4000.                                                              
//------------------------------------------------------------------------------------------

   pfvf_attr_struct pfvf_attr [pfvf_type_t] = '{
      PF0:     '{3'd0, 11'd0, 1'b0},
      PF0_VF0: '{3'd0, 11'd0, 1'b1},
      PF0_VF1: '{3'd0, 11'd1, 1'b1},
      PF0_VF2: '{3'd0, 11'd2, 1'b1},
      PF1:     '{3'd1, 11'd0, 1'b0},
      PF2:     '{3'd2, 11'd0, 1'b0},
      PF3:     '{3'd3, 11'd0, 1'b0},
      PF4:     '{3'd4, 11'd0, 1'b0}
   };

   pfvf_addr_t pfvf_addr [pfvf_type_t] = '{
      PF0:     64'h0000_0000_8000_0000,
      PF0_VF0: 64'h9000_0000_0000_0000,
      PF0_VF1: 64'h9000_0000_0100_0000,
      PF0_VF2: 64'h9000_0000_0200_0000,
      PF1:     64'h0000_0000_a000_0000,
      PF2:     64'h0000_0000_c000_0000,
      PF3:     64'h0000_0000_e000_0000,
      PF4:     64'h0000_0001_0000_0000
   };

   //pfvf_type_t pfvf_lookup [pfvf_attr_vector_t] = '{
   pfvf_type_t pfvf_lookup [pfvf_attr_struct] = '{
      '{3'd0, 11'd0, 1'b0}: PF0,
      '{3'd0, 11'd0, 1'b1}: PF0_VF0,
      '{3'd0, 11'd1, 1'b1}: PF0_VF1,
      '{3'd0, 11'd2, 1'b1}: PF0_VF2,
      '{3'd1, 11'd0, 1'b0}: PF1,
      '{3'd2, 11'd0, 1'b0}: PF2,
      '{3'd3, 11'd0, 1'b0}: PF3,
      '{3'd4, 11'd0, 1'b0}: PF4
   };

   function automatic pfvf_type_t get_pfvf_type_from_index(input bit[2:0] pfn, input bit[10:0] vfn, input bit vfa);
      pfvf_attr_struct pfvf_index = '{pfn,vfn,vfa};
      return pfvf_lookup[pfvf_index];
   endfunction

   function automatic pfvf_attr_struct get_pfvf_attr_from_index(input bit[2:0] pfn, input bit[10:0] vfn, input bit vfa);
      pfvf_type_t pfvf_selected = get_pfvf_type_from_index(pfn,vfn,vfa);
      return pfvf_attr[pfvf_selected];
   endfunction

   function automatic pfvf_addr_t get_pfvf_addr_from_index(input bit[2:0] pfn, input bit[10:0] vfn, input bit vfa);
      pfvf_type_t pfvf_selected = get_pfvf_type_from_index(pfn,vfn,vfa);
      return pfvf_addr[pfvf_selected];
   endfunction

   function automatic pfvf_type_t get_pfvf_type_from_int_indices(input int pfn, input int vfn, input bit vfa);
      if (|(pfn & 32'hffff_fff8))
      begin
         $fatal(1, "Argument pfn to function get_pfvf_type_from_int_indices was out of 3-bit range:%0d %0x !", pfn, pfn);
      end
      if (|(vfn & 32'hffff_f800))
      begin
         $fatal(1, "Argument vfn to function get_pfvf_type_from_int_indices was out of 11-bit range:%0d %0x !", vfn, vfn);
      end
      bit[2:0] pfn_bit = 3'(pfn);
      bit[10:0] vfn_bit = 11'(vfn);
      pfvf_attr_struct pfvf_index = '{pfn_bit,vfn_bit,vfa};
      return pfvf_lookup[pfvf_index];
   endfunction

   function automatic pfvf_attr_struct get_pfvf_attr_from_int_indices(input int pfn, input int vfn, input bit vfa);
      pfvf_type_t pfvf_selected = get_pfvf_type_from_int_indices(pfn,vfn,vfa);
      return pfvf_attr[pfvf_selected];
   endfunction

   function automatic pfvf_addr_t get_pfvf_addr_from_int_indices(input int pfn, input int vfn, input bit vfa);
      pfvf_type_t pfvf_selected = get_pfvf_type_from_int_indices(pfn,vfn,vfa);
      return pfvf_addr[pfvf_selected];
   endfunction


endpackage: pfvf_def_pkg_host

`endif // `ifndef __PFVF_DEF_PKG_HOST__
