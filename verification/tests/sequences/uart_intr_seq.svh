// Copyright (C) 2023 Intel Corporation
// SPDX-License-Identifier: MIT

//===============================================================================================================
/**
 * Abstract:
 * class uart_intr_seq is executed by uart_intr_test .
 * 
 * This sequnce verifies the functionality of the UART inturrput. 
 * The intruppt is generated by forcing / writing the error register .
 * PBA mechanism is verified using masking and un-masking the intruppt vector
 * Sequnce is running on virtual_sequencer.
 *
 *
**/
//==============================================================================================================

`ifndef UART_INTR_SEQ_SVH
`define UART_INTR_SEQ_SVH

class uart_intr_seq extends base_seq;
    `uvm_object_utils(uart_intr_seq)
    `uvm_declare_p_sequencer(virtual_sequencer)

  rand bit[63:0]    intr_addr;
  rand bit[63:0]    intr_wr_data;
  rand bit[63:0]    ras_err_code;//1:CatastError, 2:FatalError, 4:NoFatalError
  rand bit[63:0]    fme_err_code;//1:PartialReconfigFIFOParityErr, 2:RemoteSTPParityErr, 32:AfuAccessModeErr
  rand bit inj_ras_err; 
  rand bit inj_fme_err; 
  static int e_set;

  rand bit [63:0] dut_mem_start;
  rand bit [63:0] dut_mem_end;

  constraint addr_cons {
     dut_mem_end > dut_mem_start;
     intr_addr[7:0] == 0;
     intr_addr   >= dut_mem_start;
     intr_addr    < dut_mem_end;
     intr_addr[63:32] == 32'b0;
  }
    
  constraint wr_dat_cons {
     !(intr_wr_data inside {64'h0});
      intr_wr_data[63:32] == 32'b0; 
  }

 
    function new(string name = "uart_intr_seq");
        super.new(name);
    endfunction : new

    task body();
        bit [63:0] wdata, rdata, addr, intr_masked_data;
        bit [63:0] afu_id_l, afu_id_h;
        bit msix_req_set;
        `PCIE_MEM_SERV target_mem_seq;


        super.body();
        `uvm_info(get_name(), "Entering uart_intr_seq...", UVM_LOW)

        repeat(3)begin

  	  this.randomize() with{dut_mem_start == tb_cfg0.dut_mem_start && dut_mem_end == tb_cfg0.dut_mem_end;};
          `uvm_info(get_name(), $psprintf("TEST: dut_mem_start=%0h dut_mem_end=%0h", dut_mem_start, dut_mem_end), UVM_LOW)

          if(fme_err_code == 20'h00001) e_set = 0;

          `uvm_info(get_name(), $psprintf("TEST: Configure MSIX Table BAR0 MSIX_ADDR5/MSIX_CTLDAT5"), UVM_LOW)
          `uvm_info(get_name(), $psprintf("TEST: MMIO WRITE to MSIX_ADDR5"), UVM_LOW)
          mmio_write64(.addr_(tb_cfg0.PF0_BAR4+FME_MSIX_BASE_ADDR+20'h50), .data_(intr_addr));
          #1us;

          `uvm_info(get_name(), $psprintf("TEST: MMIO WRITE to MSIX_CTLDAT5 with masked Interrupt"), UVM_LOW)
          intr_masked_data[31:0] = intr_wr_data[31:0];
          intr_masked_data[63:32] = 32'b1; 
          mmio_write64(.addr_(tb_cfg0.PF0_BAR4+FME_MSIX_BASE_ADDR+'h58), .data_(intr_masked_data));
          #25us;
 
          `uvm_info(get_name(), $psprintf("TEST: Inject UART interrupt"), UVM_LOW)
	      force `UART_TOP.uart_irq_50m = 1'b1 ;

	  /*msix_req_set = 0;
	  `uvm_info(get_name(), $psprintf("TEST: Poll for MSIX interrupt requests"), UVM_LOW)
          fork 
            begin
               #10us;
            end
            begin
             `uvm_info(get_type_name(),$sformatf("Waiting for MSIX Interrupt Req"),UVM_LOW)
	     @(posedge `ST2MM_TOP.axis_tx_msix_bridge.msix_fifo_valid)
             if(`ST2MM_TOP.axis_tx_msix_bridge.intr_hdr.vector_num[15:0]==5) //for UART intr
               msix_req_set = 1'b1;
            end
          join_any
          disable fork;

          if(msix_req_set)                                                                      
            `uvm_fatal(get_type_name(),"TEST: msix_req generated for masked fme interrupt")
          else
            `uvm_info(get_name(), $psprintf("TEST: msix_req not generated for masked interrupt"), UVM_LOW)*/


	   #1us;
          `uvm_info(get_name(), $psprintf("TEST: Check MSIX_PBA[5] is set for masked UART interrupt"), UVM_LOW)
          for(int i=0;i<200;i++) begin
            //mmio_read64(.addr_(tb_cfg0.PF0_BAR4+20'h0_2000),.data_(rdata));
            mmio_read64(.addr_(tb_cfg0.PF0_BAR4+FME_MSIX_BASE_ADDR+'h70),.data_(rdata));
            if(rdata[5]) break;
            #1ns;
          end
          assert(rdata[5]) else 
            `uvm_error(get_type_name(),$sformatf("TEST : MSIX_PBA[5] not set post masked interrupt"))

          `uvm_info(get_name(), $psprintf("TEST: Unmasked UART interrupt by writing on MSIX_CTLDAT5[63:32]"), UVM_LOW)
          mmio_write64(.addr_(tb_cfg0.PF0_BAR4+FME_MSIX_BASE_ADDR+'h58), .data_(intr_wr_data));

	  /*msix_req_set = 0;
	  `uvm_info(get_name(), $psprintf("TEST: Poll for MSIX interrupt requests"), UVM_LOW)
          fork 
            begin
               #10us;
            end
            begin
             `uvm_info(get_type_name(),$sformatf("Waiting for MSIX Interrupt Req"),UVM_LOW)
	     @(posedge `ST2MM_TOP.axis_tx_msix_bridge.msix_fifo_valid)
             if(`ST2MM_TOP.axis_tx_msix_bridge.intr_hdr.vector_num[15:0]==5) //for UART intr
               msix_req_set = 1'b1;
            end
          join_any
          disable fork;

          if(!msix_req_set)                                                                      
                `uvm_fatal(get_type_name(), "TEST: msix_req not generated after unmasking FME interrupt")
          else
            `uvm_info(get_name(), $psprintf("TEST: msix_req generated after unmasking FME interrupt"), UVM_LOW)*/

          #1us;
          `uvm_info(get_name(), $psprintf("TEST: Check MSIX_PBA[5] is clear after asserting pending UART interrupt"), UVM_LOW)
          //mmio_read64(.addr_(tb_cfg0.PF0_BAR4+20'h0_2000),.data_(rdata));
          mmio_read64(.addr_(tb_cfg0.PF0_BAR4+FME_MSIX_BASE_ADDR+'h70),.data_(rdata));
          assert(rdata[5]==0) else 
            `uvm_error(get_type_name(),$sformatf("TEST : MSIX_PBA[5] is not clear after asserting pending UART interrupt"));

          `uvm_info(get_name(), $psprintf("TEST: Read Host memory"), UVM_LOW)
          `uvm_do_on_with(target_mem_seq, p_sequencer.root_virt_seqr.mem_target_seqr, {
              service_type      == `PCIE_MEM_SERV::READ_BUFFER;
              address           == intr_addr;
              dword_length      == 1;
              first_byte_enable == 4'hF;
              last_byte_enable  == 4'hF;
              byte_enables      == 4'hF;
          })

          if(changeEndian(target_mem_seq.data_buf[0]) !== intr_wr_data)
              `uvm_error(get_name(), $psprintf("Interrupt write data mismatch exp = %0h act = %0h", intr_wr_data, changeEndian(target_mem_seq.data_buf[0])))
          else
              `uvm_info(get_name(), $psprintf("TEST: Interrupt data match intr_addr=%0h intr_wr_data = %0h", intr_addr, intr_wr_data), UVM_LOW)

          release `UART_TOP.uart_irq_50m; 

          msix_req_set = 0;
          #1us;
        end

       `uvm_info(get_name(), "Exiting uart_intr_seq...", UVM_LOW)

    endtask : body

endclass : uart_intr_seq

`endif // uart_intr_SEQ_SVH
